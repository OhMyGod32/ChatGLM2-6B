{"id": 0, "inputs_pretokenized": "用于确定字符串模式的一个规则集称为____。\nA. 字符串匹配\nB. 正则表达式\nC. 文件名匹配\nD. 过滤器", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 1, "inputs_pretokenized": "将作业部分或全部移到外存，以调入其他的作业的技术称为____。\nA. 覆盖技术\nB. 对换技术\nC. 虚拟内存\nD. 物理扩充", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 2, "inputs_pretokenized": "在Unix的单处理机系统中，处于SRUN状态的进程____。\nA. 只有一个\nB. 可以有多个\nC. 不能被挂起\nD. 必须在执行完后才能被撤下", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 3, "inputs_pretokenized": "静态地址重定位的结果是得到____。\nA. 源程序\nB. 静态代码\nC. 目标代码\nD. 执行代码", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 4, "inputs_pretokenized": "若执行信号量操作的进程数为3，信号量S初值为2，当前值为-1表示有____个等待相关临界资源的进程。\nA. 0\nB. 1\nC. 2\nD. 3", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 5, "inputs_pretokenized": "作业调度程序从处于____状态的队列中选取适当的作业调入主系统。\nA. 就绪\nB. 提交\nC. 后备\nD. 等待", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 6, "inputs_pretokenized": "用于连接大量低速或中速的I/O设备的通道设备是____。\nA. 字节多路通道\nB. 数据选择通道\nC. 成组多路通道\nD. I/O通道", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 7, "inputs_pretokenized": "在Unix中，系统管理程序，系统配置程序等是放在____目录中的。\nA. /bin\nB. /lib\nC. /etc\nD. /dev", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 8, "inputs_pretokenized": "有时分配页面多，反而有可能产生更多的缺页中断的页面淘汰算法是____。\nA. 最优淘汰算法（OPT）\nB. 先进先出淘汰算法（FIFO）\nC. 最近最少使用淘汰算法（LRU）\nD. 最近未使用淘汰算法（NUR）", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 9, "inputs_pretokenized": "采用覆盖技术的目的是____。\nA. 能运行更多的程序\nB. 能运行更大的程序\nC. 实现分时系统\nD. 实现虚拟存储技术", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 10, "inputs_pretokenized": "在Unix中，创建一个共享内存段的系统调用是____。\nA. seumget\nB. creatsem\nC. msgget\nD. shmget", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 11, "inputs_pretokenized": "在Unix系统中，下列proc结构的成员中与进程图象的调入有关的是____。\nA. p_sig\nB. p_time\nC. p_cpu\nD. p_nice", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 12, "inputs_pretokenized": "在下面的Socket远程通信的系统调用中____是客户端程序中要用到的系统调用。\nA. bind\nB. listen\nC. accept\nD. connect", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 13, "inputs_pretokenized": "Unix的切换调度程序swtch的第一部分和第三部分涉及进程现场的保护和恢复，在该程序中保护和恢复的一般是____的现场。\nA. 系统进程\nB. 用户进程\nC. 同一个进程\nD. 不同的进程", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 14, "inputs_pretokenized": "操作系统对于带有预读的字符块读入采用____方式。\nA. 同步读\nB. 延迟读\nC. 异步读\nD. 重复读", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 15, "inputs_pretokenized": "父进程刚执行了系统调用fork创建一个子进程后，这个子进程的初始状态为____。\nA. 创建状态\nB. 睡眠状态\nC. 就绪状态\nD. 等待状态", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 16, "inputs_pretokenized": "在Unix中超级网络服务监控进程管理的服务项目是在系统配置文件____中设定的。\nA. /etc/inetd.conf\nB. /etc/networks\nC. /etc/services\nD. /etc/protocols", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 17, "inputs_pretokenized": "Unix的初始化程序要扫描____文件。\nA. inittab\nB. passwd\nC. hosts\nD. services", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 18, "inputs_pretokenized": "系统出现死锁的原因是____。\nA. 计算机系统发生了重大故障\nB. 系统中所有的进程都被封锁了\nC. 若干进程因竞争资源而无休止地等待着，不释放已占有的资源\nD. 进程同时申请的资源数大大超过资源总数", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 19, "inputs_pretokenized": "在进行作业调度时，要想兼顾作业等待时间和计算时间，应选取____。\nA. 均衡调度算法\nB. 短作业优先调度算法\nC. 先来先服务算法\nD. 最高响应比优先算法", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 20, "inputs_pretokenized": "操作系统设置____，用来记录计算机系统所配置的独占设备类型、台数和分配情况。\nA. 设备分配表\nB. 设备类表\nC. 设备表\nD. 设备控制表", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 21, "inputs_pretokenized": "一个采用单纯二级索引的文件系统，文件块大小为4KB，文件块地址用4字节表示，则能管理的最大文件是____。\nA. 8GB\nB. 4GB\nC. 2GB\nD. 1GB", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 22, "inputs_pretokenized": "下列机构中不能用于进程间数据通信的是____。\nA. 消息\nB. 共享存储区\nC. 信号量\nD. 管道", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 23, "inputs_pretokenized": "Shell的上一命令的返回状态变量是____。\nA. $？\nB. $$\nC. $!\nD. $-", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 24, "inputs_pretokenized": "根据作业在本次分配到的内存起始地址将目标代码装到指定内存地址中，并修改所有有关地址部分的值的方法称为____方式。\nA. 固定定位\nB. 静态重定位\nC. 动态重定位\nD. 单一连续重定位", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 25, "inputs_pretokenized": "在Unix系统中，核心发现了可能更适合占用处理机的进程，设置了强迫调度标志____。\nA. runout\nB. runin\nC. runrun\nD. flag", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 26, "inputs_pretokenized": "采用动态重定位技术优点之一是____。\nA. 在程序执行期间可动态地变换映像在内存空间的地址\nB. 程序在执行前就可决定装入内存的地址\nC. 能用软件实施地址变换\nD. 动态重定位的程序占用的内存资源较少", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 27, "inputs_pretokenized": "如果用户对目录/temp只有x（执行）权限，那么该用户不能进行的操作为____。\nA. 删除目录/temp\nB. 对目录/temp改名\nC. 列出目录/temp下的文件\nD. 进入目录/temp", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 28, "inputs_pretokenized": "在段式虚存管理系统中，分段是由____完成的。\nA. 程序员\nB. 编译程序\nC. 连接装入程序\nD. 操作系统", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 29, "inputs_pretokenized": "死锁的防止是根据____采取措施实现的。\nA. 配置足够的系统资源\nB. 使进程的推进顺序合理\nC. 破坏产生死锁的四个必要条件之一\nD. 避免系统进入不安全状态", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 30, "inputs_pretokenized": "Linux中的可由用户配置的登录初始化文件是____。\nA. .bash_profile\nB. profile\nC. .bashrc\nD. .login", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 31, "inputs_pretokenized": "下面____命令是关闭Linux系统。\nA. init 6\nB. init 0\nC. init 1\nD. init 3", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 32, "inputs_pretokenized": "下面的符号中，错误的I/O转向符号是____。\nA. <\nB. >\nC. <<\nD. >>", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 33, "inputs_pretokenized": "Spooling系统提高了____的利用率。\nA. 独占设备\nB. 共享设备\nC. 虚拟设备\nD. 用户设备", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 34, "inputs_pretokenized": "并发进程指的是____进程。\nA. 可并行执行\nB. 可同时执行\nC. 可先后执行\nD. 可配合执行", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 35, "inputs_pretokenized": "请求分页存储管理的页表表项中的修改位，供____参考。\nA. 程序修改\nB. 分配页面\nC. 淘汰页面\nD. 调入页面", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 36, "inputs_pretokenized": "一个命令的输出结果作为下一个命令的输入，这种机制称为____。\nA. 管道\nB. Shell过程\nC. 输入/输出转向\nD. 控制流", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 37, "inputs_pretokenized": "在Windows系统中，单靠____并不能达到文件保密的目的。\nA. 隐蔽文件目录\nB. 建立保密文件夹\nC. 使用密码\nD. 规定文件使用权限", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 38, "inputs_pretokenized": "在下列死锁解决方案中，属于死锁预防的是____。\nA. 银行家算法\nB. 资源有序分配法\nC. 状态图或状态表\nD. 撤销死锁进程", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 39, "inputs_pretokenized": "记录了TCP/IP的各个网络服务名、对应的端口号的文件是____。\nA. /etc/inetd.conf\nB. /etc/networks\nC. /etc/services\nD. /etc/protocols", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 40, "inputs_pretokenized": "在Unix中，从以文件类型分，主要可分为____。\nA. 普通文件、目录文件和特别文件\nB. 系统文件、目录文件和特别文件\nC. 数据文件、普通文件和目录文件\nD. 临时文件、永久文件和特别文件", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 41, "inputs_pretokenized": "系统出现死锁的根本原因是____。\nA. 系统资源太少\nB. 系统中进程太多\nC. 资源的独占性\nD. 资源管理和进程推进顺序都不得当", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 42, "inputs_pretokenized": "临界区是指并发进程中____。\nA. 用于实现进程互斥的程序段\nB. 用于实现进程同步的程序段\nC. 用于实现进程通信的程序段\nD. 与互斥的共享资源有关的程序段", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 43, "inputs_pretokenized": "不会产生“内零头”的存储管理方法是____存储管理。\nA. 单一连续区\nB. 可变分区\nC. 页式\nD. 段页式", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 44, "inputs_pretokenized": "静态地址重定位的对象是____。\nA. 源程序\nB. 编译程序\nC. 目标程序\nD. 执行程序", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 45, "inputs_pretokenized": "在____操作系统中，计算机能及时处理由过程控制反馈的数据并做出响应。\nA. 实时\nB. 分时\nC. 作业处理\nD. 控制", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 46, "inputs_pretokenized": "Windows系统的早期研制目标是在MS-DOS基础上提供一个____。\nA. 单任务的图形用户界面\nB. 多任务的图形用户界面\nC. 多种操作系统的工作环境\nD. 网络管理系统", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 47, "inputs_pretokenized": "设cmd_=_who，以下4个命令中，执行结果与其他不同的命令是____。\nA. eval $cmd\nB. eval '$cmd'\nC. eval `$cmd`\nD. eval \"$cmd\"", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 48, "inputs_pretokenized": "在批处理系统中，周转时间是____。\nA. 作业运行时间\nB. 作业等待时间和运行时间之和\nC. 作业的相对等待时间\nD. 作业获得时间片的时间", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 49, "inputs_pretokenized": "在BLP多级强制访问保密模型中，当主体的安全级高于客体的安全级时____。\nA. 主体不可读客体但可写客体\nB. 主体可读客体也可写客体\nC. 主体可读客体但不可写客体\nD. 主体可自行决定是否能读写客体", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 50, "inputs_pretokenized": "Unix_System_V的调度原理是基于____。\nA. 先来先服务\nB. 短作业优先\nC. 时间片轮转\nD. 多级反馈调度算法", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 51, "inputs_pretokenized": "管道允许读/写进程按____的次序方式传送数据。\nA. 先进先出\nB. 后进先出\nC. 用户要求\nD. 顺序", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 52, "inputs_pretokenized": "在一个单处理机系统中，有若干进程轮流占有处理机，称之为____。\nA. 顺序执行\nB. 轮转执行\nC. 并行执行\nD. 并发执行", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 53, "inputs_pretokenized": "读者∕写者是一个____问题。\nA. 互斥\nB. 半同步\nC. 全同步\nD. 共享", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 54, "inputs_pretokenized": "用户编制的程序与实际使用的物理设备无关是由____功能实现的。\nA. 设备分配\nB. 设备驱动\nC. 虚拟设备\nD. 设备独立性", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 55, "inputs_pretokenized": "Unix和Linux的访问联机手册的命令是____。\nA. man\nB. spell\nC. find\nD. more", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 56, "inputs_pretokenized": "在Unix中，passwd文件是放在____目录中的。\nA. /bin\nB. /lib\nC. /etc\nD. /dev", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 57, "inputs_pretokenized": "为了解决CPU与外部设备的速度匹配问题，可采用____。\nA. 并行技术\nB. 预读技术\nC. 中断技术\nD. 虚存技术", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 58, "inputs_pretokenized": "源程序经过编译或者汇编生成的机器指令集合，称为____。\nA. 源程序\nB. 目标程序\nC. 可执行程序\nD. 非执行程序", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 59, "inputs_pretokenized": "存取盘块中的信息一般可分几部分时间，其中花费最多的是____。\nA. 等待时间\nB. 寻道时间\nC. 传送时间\nD. 访问时间", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 60, "inputs_pretokenized": "在Unix类操作系统中，____可用于通知进程发生了异常的事件。\nA. 信号机构\nB. 管道机构\nC. 消息机构\nD. 信号量", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 61, "inputs_pretokenized": "在Unix中，若一个缓冲控制块buf处于设备队列，则它还可能位于____。\nA. NODEV队列或I/O请求队列\nB. 自由队列或I/O请求队列\nC. 另一设备队列或NODEV队列\nD. NODEV队列或自由队列", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 62, "inputs_pretokenized": "Unix中的一个Shell程序相当于一个____。\nA. 作业\nB. 进程\nC. 线程\nD. 命令", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 63, "inputs_pretokenized": "用于控制和维护程序的各个历史版本的软件是____。\nA. sdb\nB. Yacc\nC. SCCS\nD. lint", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 64, "inputs_pretokenized": "同一进程内的并发线程之间可通过____传递信息。\nA. 全局变量\nB. 动态变量\nC. 函数参数\nD. 工作区", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 65, "inputs_pretokenized": "通道又称I/O处理机，它能实现____之间的信息传输。\nA. 主存和外设\nB. CPU和外设\nC. 外存和外设\nD. 主存和CPU", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 66, "inputs_pretokenized": "操作系统对数据进行管理的部分叫做____。\nA. 数据库系统\nB. 文件系统\nC. 数据存储系统\nD. 信息管理系统", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 67, "inputs_pretokenized": "装入到地址寄存器的地址为____。\nA. 符号名地址\nB. 虚拟地址\nC. 相对地址\nD. 物理地址", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 68, "inputs_pretokenized": "在操作系统中，____。\nA. 不同用户的进程之间不可以并发执行，同一个用户的进程之间可以并发执行\nB. 进程之间不可以并发执行，一个进程中的多个线程之间可以并发执行\nC. 不同进程之间可以并发执行，同一进程中的多个线程之间也可以并发执行\nD. 不同进程的线程之间不可以并发执行，同一个进程的线程之间可以并发执行", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 69, "inputs_pretokenized": "Unix系统的多用户状态运行级是____。\nA. 1\nB. 2\nC. 3\nD. 6", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 70, "inputs_pretokenized": "可以在不同系统之间传送文件的程序是____。\nA. ftp\nB. rcp\nC. write\nD. telnet", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 71, "inputs_pretokenized": "在操作系统中，JCB是指____。\nA. 作业控制块\nB. 进程控制块\nC. 文件控制块\nD. 程序控制块", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 72, "inputs_pretokenized": "在某一时刻，进程P1和P2已执行或将执行各处于下列关于互斥资源的操作序列：进程P1已申请到资源S1，申请资源S2，释放资源S1；进程P2已申请到资源S2，申请资源S1，释放资源S2，系统继续并发执行进程P1，P2，系统将____。\nA. 必定产生死锁\nB. 可能产生死锁\nC. 不会产生死锁\nD. 无法确定是否会产生死锁", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 73, "inputs_pretokenized": "在分页系统中，程序员编写的程序的虚地址空间是____的。\nA. 连续\nB. 不连续\nC. 分块\nD. 分段", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 74, "inputs_pretokenized": "在Biba完整性模型中，当主体的安全级高于客体的安全级时____。\nA. 主体不可读客体但可写客体\nB. 主体可读客体也可写客体\nC. 主体可读客体但不可写客体\nD. 主体可自行决定是否能读写客体", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 75, "inputs_pretokenized": "Shell查找命令时在文件系统中的查找路径的Shell变量是____。\nA. HOME\nB. PATH\nC. PS1\nD. CDPATH", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 76, "inputs_pretokenized": "表示命令行所有位置参数的Shell变量是____。\nA. $*\nB. $?\nC. $$\nD. $!", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 77, "inputs_pretokenized": "在Windows_9x系统中，用于管理磁盘数据区的数据结构是____。\nA. 位图\nB. 空闲块表\nC. 文件分配表\nD. 文件控制块", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 78, "inputs_pretokenized": "资源的按序分策略可以破坏产生死锁的____条件。\nA. 互斥执行\nB. 保持并等待\nC. 不可剥夺\nD. 循环等待", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 79, "inputs_pretokenized": "在Unix中的将计算机名映射为IP地址的文件是____。\nA. /etc/hosts\nB. /etc/networks\nC. /etc/services\nD. /etc/protocols", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 80, "inputs_pretokenized": "下列操作系统中，能作为服务器的操作系统是____。\nA. MS-DOS\nB. Windows3.x\nC. Windows NT\nD. Windows 98", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 81, "inputs_pretokenized": "Unix的用于显示进程的状态的命令是____。\nA. ps\nB. pid\nC. stat\nD. kill", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 82, "inputs_pretokenized": "下面选项中不是进程睡眠原因的是____。\nA. 临界区或资源互斥\nB. 同步等待出现处理对象\nC. 同步等待I/O完成\nD. 进程映象被换出至盘交换区", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 83, "inputs_pretokenized": "固定分区存储管理一般采用____进行主存空间的分配。\nA. 首次适应分配算法\nB. 循环首次适应分配算法\nC. 最优适应分配算法\nD. 顺序分配算法", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 84, "inputs_pretokenized": "类似于电子邮件系统的进程间的通信方法是____通信。\nA. 管道\nB. 共享存储区\nC. 信号量\nD. 消息", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 85, "inputs_pretokenized": "Windows_NT的存储管理所采用的页面淘汰算法是____。\nA. OPT\nB. FIFO\nC. LRU\nD. NUR", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 86, "inputs_pretokenized": "批处理的目的是____。\nA. 提供多道程序功能\nB. 提供多用户功能\nC. 提供分时共享功能\nD. 提高CPU的利用率", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 87, "inputs_pretokenized": "一个进程被强迫剥夺处理机后，它将处于____状态。\nA. 执行态\nB. 就绪态\nC. 阻塞态\nD. 不能确定", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 88, "inputs_pretokenized": "不能利用____实现父子进程间的互斥。\nA. 文件\nB. 外部变量\nC. 信号量\nD. 锁", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 89, "inputs_pretokenized": "在Windows_2000中，只有____状态的线程才能成为被切换成运行状态，占用处理器执行。\nA. 备用\nB. 就绪\nC. 等待\nD. 转换", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 90, "inputs_pretokenized": "下面5个系统中：计算机辅助设计系统、航班定票系统、过程控制系统、计算机激光照排系统、CD播放器，必须是实时操作系统的有____个。\nA. 1\nB. 2\nC. 3\nD. 4", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 91, "inputs_pretokenized": "与文件系统关系密切的系统调用是____。\nA. exit\nB. signal\nC. exec\nD. shmctl", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 92, "inputs_pretokenized": "计算机软件分为____。\nA. 程序、数据和文档\nB. 操作系统和语言处理软件\nC. 系统软件和应用软件\nD. 操作系统、编译程序和数据库管理软件", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 93, "inputs_pretokenized": "在NTFS文件系统中，文件在磁盘上存储时的物理结构是采用____结构。\nA. 连续\nB. 链接\nC. 索引\nD. 组合", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 94, "inputs_pretokenized": "在Unix中，父进程使用系统调用fork()创建一子进程后，这时____。\nA. 父子进程具有相同的proc结构\nB. 父子进程对信号的处理方式相同\nC. 父子进程共享同一个工作区\nD. 子进程可使用系统调用wait( )等待父进程的终止", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 95, "inputs_pretokenized": "用共享设备去模拟独占设备，从而达到共享、快速的效果的设备称为____。\nA. 模拟设备\nB. 系统设备\nC. 共享设备\nD. 虚拟设备", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 96, "inputs_pretokenized": "在单CPU的操作系统中，当前共有4个进程，如Unix的核心函数sched正在将盘交换区的一个进程调入内存，系统中至少有____个进程处于运行（SRUN）状态。\nA. 1\nB. 2\nC. 3\nD. 4", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 97, "inputs_pretokenized": "一个运行的进程用完了分配给它的时间片后，它的状态转变为____状态。\nA. 阻塞\nB. 睡眠\nC. 就绪\nD. 终止", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 98, "inputs_pretokenized": "防止信息失效或变得不可存取是指信息的____。\nA. 保密性\nB. 完整性\nC. 可靠性\nD. 可用性", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 99, "inputs_pretokenized": "解决进程间同步与互斥问题的常用方法是使用____。\nA. 锁操作\nB. 存储管理\nC. 信号机构\nD. 信号量", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 100, "inputs_pretokenized": "在Unix中，系统管理程序和系统配置等文件是放在____目录中的。\nA. /bin\nB. /lib\nC. /etc\nD. /dev", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 101, "inputs_pretokenized": "下列作业调度算法中，作业平均周转时间最短的是____。\nA. 先来先服务法\nB. 短作业优先法\nC. 优先数法\nD. 时间片轮转法", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 102, "inputs_pretokenized": "必定会引起进程切换的状态转换是____。\nA. 一个进程被创建后进入就绪态\nB. 一个进程从运行态变成阻塞态\nC. 一个进程从就绪态变成运行态\nD. 一个进程从等待态变成就绪态", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 103, "inputs_pretokenized": "在Unix系统中，一个在盘交换区上处于睡眠的进程,_它____。\nA. 能被调度执行\nB. 能被换入内存\nC. 能执行I/O中断处理程序\nD. 能接收到信号", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 104, "inputs_pretokenized": "在进程之间要传递大量的数据，效率高而且互斥与同步控制方便的方法是采用____。\nA. 管道\nB. 共享存储区\nC. 全局变量\nD. 信号量", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 105, "inputs_pretokenized": "shell解释双引号中的字符时，没有特殊含义的字符是____。\nA. $\nB. \\\nC. `\nD. *", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 106, "inputs_pretokenized": "进程间的互斥与同步表示了各进程间的____。\nA. 竞争与协作\nB. 相互独立与相互制约\nC. 临界区调度原则\nD. 动态性与并发性", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 107, "inputs_pretokenized": "以下____是关于Unix流文件的函数。\nA. rewind\nB. system\nC. sscanf\nD. fstat", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 108, "inputs_pretokenized": "Shell在Unix操作系统中位于____之间。\nA. 硬件层和核心层\nB. 核心层和系统调用层\nC. 系统调用层和应用程序层\nD. 应用程序层和用户", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 109, "inputs_pretokenized": "在以下存贮管理方案中，不适用于多道程序设计系统的是____。\nA. 单一连续区分配\nB. 固定式分区分配\nC. 可变式分区分配\nD. 页式存贮管理", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 110, "inputs_pretokenized": "一段不能由多个进程同时执行的代码称为____。\nA. 临界区\nB. 临界资源\nC. 锁操作\nD. 信号量操作", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 111, "inputs_pretokenized": "用____可以防止共享文件可能造成的破坏，但实现起来系统开销大。\nA. 目录和文件的许可权规定\nB. 存取控制表\nC. 不同用户对文件的使用权\nD. 隐蔽文件目录", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 112, "inputs_pretokenized": "如果系统只有一个临界资源，同时有很多进程要竞争该资源，那么系统____发生死锁。\nA. 一定会\nB. 一定不会\nC. 不一定会\nD. 由进程数量决定", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 113, "inputs_pretokenized": "在磁盘存储器中，无需移动读写头即可读写的一组磁道称为____。\nA. 扇区\nB. 柱面\nC. 盘面\nD. 分区", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 114, "inputs_pretokenized": "在可变式分区存储管理中，当释放和回收一个空闲区时，造成空闲表项区数减1的情况是____。\nA. 无上邻空闲区，也无下邻空闲区\nB. 有上邻空闲区，但无下邻空闲区\nC. 有下邻空闲区，但无上邻空闲区\nD. 有上邻空闲区，也有下邻空闲区", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 115, "inputs_pretokenized": "当对磁盘的存取很繁忙时，下列的调度算法中，平均等待时间最大的调度算法是____。\nA. 先来先服务调度（FCFS）\nB. 最短寻道时间优先法（SSTF）\nC. 电梯调度算法（SCAN）\nD. 巡回扫描法  (C-SCAN)", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 116, "inputs_pretokenized": "下面几种操作中，____不是操作系统的特权操作。\nA. 执行I/O 操作\nB. 开、关中断\nC. 存取用户映像的页表\nD. 系统调用", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 117, "inputs_pretokenized": "ls_–l命令不能够列出文件的____。\nA. 软链接数\nB. 硬链接数\nC. 文件类型\nD. 文件长度", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 118, "inputs_pretokenized": "在多进程的并发系统中，肯定不会因竞争____而产生死锁。\nA. 打印机\nB. 磁带机\nC. 光刻机\nD. 处理机", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 119, "inputs_pretokenized": "Windows_2000/XP在x86体系结构上利用____页表来实现虚拟地址到物理地址的转换。\nA. 一级\nB. 二级\nC. 三级\nD. 四级", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 120, "inputs_pretokenized": "文件索引结构的特点是____。\nA. 打开文件以后，要占用较多的额外内存空间\nB. 适合于记录式文件，不适合于无结构的流式文件\nC. 文件索引表占的空间比索引顺序文件和散列文件表大\nD. 局部修改时，插入、删除一个文件块较链接结构文件和散列文件费时", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 121, "inputs_pretokenized": "在使用Spooling技术的系统中，用户作业的打印输出结果将被送到____。\nA. 磁盘区域\nB. 内存区域\nC. 屏幕\nD. 打印机", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 122, "inputs_pretokenized": "一组管道线命令的出口状态是它的____命令的出口状态。\nA. 第一个\nB. 最后一个\nC. 任何一个\nD. 所有", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 123, "inputs_pretokenized": "在单CPU的操作系统中，如当前共有4个进程，其中1个进程在核心态下执行，至少有____个进程处于核心态。\nA. 1\nB. 2\nC. 3\nD. 4", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 124, "inputs_pretokenized": "动态重定位是在程序的____中进行的。\nA. 编译过程\nB. 连接过程\nC. 装入过程\nD. 执行过程", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 125, "inputs_pretokenized": "在不考虑联想寄存器和Cache的段页式存储管理中，每次从主存中取指令或取操作数，要访问主存____次。\nA. 1\nB. 2\nC. 3\nD. 4", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 126, "inputs_pretokenized": "用户要能用cd命令进入一个目录，就要有对该目录的____。\nA. 读许可\nB. 写许可\nC. 执行许可\nD. 读、写和执行全部许可", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 127, "inputs_pretokenized": "相继地剥夺进程所占的资源，直至相关进程能继续运行是一种____方法。\nA. 死锁预防\nB. 死锁避免\nC. 死锁检测\nD. 死锁解除", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 128, "inputs_pretokenized": "在下列关于线程的描中，说法____是错误的。\nA. 进程内的一个执行单元\nB. 具有独立的用户栈和核心栈\nC. 进程内的一个可调度实体\nD. 进程内的一个资源分配单位", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 129, "inputs_pretokenized": "作业与进程的主要区别是____。\nA. 前者是由用户提交，后者是由系统自动生成\nB. 两者执行不同的程序段\nC. 后者可并发执行，前者则不行\nD. 前者是批处理的，后者是分时的", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 130, "inputs_pretokenized": "采用单一连续区存储管理时，若作业地址空间大于空闲内存空间，可采用____把不会同时工作的程序段轮流装入主存区执行。\nA. 对换技术\nB. 可变分区技术\nC. 虚拟存储技术\nD. 覆盖技术", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 131, "inputs_pretokenized": "在Unix系统中，如有n个进程因等待资源R而睡眠，现该资源R被释放了，系统将唤醒____。\nA. 资源R睡眠队列中的第一个进程\nB. 最早因等待资源R而睡眠的进程\nC. 最后因等待资源R而睡眠的进程\nD. 因等待资源R而睡眠全部n个进程", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 132, "inputs_pretokenized": "Linux的页面分配和释放算法采用____。\nA. 首次适应法\nB. 循环首次适应法\nC. 最佳适应算法\nD. 伙伴算法", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 133, "inputs_pretokenized": "在可变分区管理方式下，在释放和回收空闲区，若已判定“空闲区表第j栏中的始址=释放的分区始址+长度”，则表示____。\nA. 归还区有上邻空闲区\nB. 归还区有下邻空闲区\nC. 归还区有上下邻空闲区\nD. 归还区无相邻空闲区", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 134, "inputs_pretokenized": "批处理是指____。\nA. 系统依次成批自动装入并执行作业\nB. 在一台处理机上同一时刻运行多个程序\nC. 在一台处理机上并发运行多个程序\nD. 在内存中有多道程序并发运行", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 135, "inputs_pretokenized": "Unix以长列表形式显示所有的文件名，包括以‘.’开头的隐显文件名的命令是____。\nA. ls -al\nB. dir\nC. ls –ai\nD. ls –lt", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 136, "inputs_pretokenized": "批处理作业调度必须遵循的一个必要条件是____可以满足被选作业的要求。\nA. 系统的主存容量\nB. 系统中的空闲内存\nC. 系统配置的资源\nD. 系统现有的尚未分配的资源", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 137, "inputs_pretokenized": "下列四种微机操作系统中，____具有多道程序设计的特点但不是分时系统。\nA. Windows NT\nB. Windows 98\nC. Windows 2000\nD. Linux", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 138, "inputs_pretokenized": "与一般用户的应用联系最多的是操作系统的____部分。\nA. 存储管理\nB. 进程管理\nC. 设备管理\nD. 文件管理", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 139, "inputs_pretokenized": "在Shell程序中，____命令可以处理由信号引起的软中断。\nA. signal\nB. kill\nC. trap\nD. break", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 140, "inputs_pretokenized": "虚拟存储器的最大极限容量____。\nA. 由外存大小决定\nB. 由指令的地址长度决定\nC. 由用户定义\nD. 由目标程序的大小决定", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 141, "inputs_pretokenized": "使用缓冲的目的是为了解决____的问题。\nA. CPU与I/O设备之间速度不匹配\nB. 节省内存\nC. 提高I/O设备的数据传送速度\nD. 提高I/O设备的利用率", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 142, "inputs_pretokenized": "用户在终端上键输入一个kill命令后，将发出了一个____。\nA. 外部中断\nB. 内部中断\nC. 软中断\nD. 自愿中断", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 143, "inputs_pretokenized": "比较两个Shell串变量最好采用____的形式。\nA. test \"$var1\" = \"$var2\"\nB. test $var1 = $var2\nC. [ $var1 = $var2 ]\nD. [ $var1 -eq $var2 ]", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 144, "inputs_pretokenized": "多道程序设计是指____。\nA. 在实时系统中并发运行多个程序\nB. 在分布系统中同一时刻运行多个程序\nC. 在一台处理机上同一时刻运行多个程序\nD. 在一台处理机上并发运行多个程序", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 145, "inputs_pretokenized": "操作系统中执行频度最高的的调度程序是____。\nA. 高级调度\nB. 中级调度\nC. 低级调度\nD. 多级调度", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 146, "inputs_pretokenized": "在Unix设备管理中，为了减少I/O次数，使用的方法有____。\nA. 采用了缓冲技术\nB. 采用了同步读的方法\nC. 增加了预读操作\nD. 采用了通道技术", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 147, "inputs_pretokenized": "操作系统对硬件的管理包括对____的管理。\nA. 运算器\nB. 控制器\nC. 地址寄存器\nD. 外部设备", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 148, "inputs_pretokenized": "在进程的执行过程中不能被修改的映像部分是____。\nA. 共享正文段\nB. 执行代码\nC. 全局变量\nD. 栈段", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 149, "inputs_pretokenized": "在可变分区存储管理中，回收一个空闲区后，空闲区管理表中不可能____。\nA. 增加一个表项\nB. 减少一个表项\nC. 表项数不变\nD. 表项内容不变", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 150, "inputs_pretokenized": "时间片轮转调度算法是为了____。\nA. 多个进程都能得到系统的及时响应\nB. 先来先服务\nC. 多个进程使用相等CPU时间\nD. 使多个进程能公平地使用处理机", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 151, "inputs_pretokenized": "CPU的执行状态分为系统态和用户态，从用户态转换到系统态的唯一途径是通过____。\nA. 修改程序状态字\nB. 中断屏蔽\nC. 系统调用\nD. 进程调度程序", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 152, "inputs_pretokenized": "信息查询系统是一种____。\nA. 实时系统\nB. 多道程序设计系统\nC. 作业处理系统\nD. 分时操作系统", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 153, "inputs_pretokenized": "在指定时刻运行一次Shell程序的命令是____。\nA. at\nB. cron\nC. sleep\nD. run", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 154, "inputs_pretokenized": "在Linux中，____在文件系统中没有相应的inode节点。\nA. 网络设备\nB. 打印机\nC. 终端\nD. 磁盘", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 155, "inputs_pretokenized": "测试并设置指令test&set是一种____。\nA. 锁操作指令\nB. 互斥指令\nC. 判断指令\nD. 信号量指令", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 156, "inputs_pretokenized": "能支持两台计算机之间的通信机制是____。\nA. Signal\nB. Pipe\nC. Ipc\nD. Socket", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 157, "inputs_pretokenized": "Unix系统中，在下列的____情况时，设置runrun标志。\nA. 进程因等待某一事件进入了高低优先权睡眠状态\nB. 进程将盘交换区的SRUN状态进程调入内存\nC. 在唤醒睡眠进程时，发现该进程优先数比curpri小\nD. 进程完成了预定任务，进入了SZOMB状态", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 158, "inputs_pretokenized": "选择作业调度算法考虑的因素之一是____。\nA. 吞吐率\nB. 交互性\nC. 及时性\nD. 安全可靠", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 159, "inputs_pretokenized": "在Unix文件管理系统中，设置内存打开文件结构主要是为了____。\nA. 减少创建文件的时间\nB. 减少打开文件所需时间\nC. 减少关闭文件所需时间\nD. 减少对一个已打开的文件进行读写的时间", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 160, "inputs_pretokenized": "在Windows_2000的设备管理中，I/O请求包（IRP）是由____建立的。\nA. 用户应用程序\nB. 文件系统驱动程序\nC. 设备驱动程序\nD. I/O管理器", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 161, "inputs_pretokenized": "Windows_2000/XP线程调度采用的是____调度算法。\nA. 先来先服务\nB. 静态优先级\nC. 可抢占的时间片轮转\nD. 可抢占的动态优先级", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 162, "inputs_pretokenized": "操作系统为了管理文件，设置了专门的数据结构——文件控制块（FCB），FCB是在执行____时建立的。\nA. 打开\nB. 读/写\nC. 链接\nD. 创建", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 163, "inputs_pretokenized": "在Unix系统中，有名管道的创建操作是____。\nA. creat\nB. pipe\nC. mknod\nD. CreateNamePipe", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 164, "inputs_pretokenized": "在____情况下，计算机系统一定出现了死锁。\nA. 系统中所有的进程都处于封锁状态\nB. 进程申请的资源数大大超过资源总数\nC. 计算机硬件或软件系统发生重大故障\nD. 两个进程互相等待对方占有的资源", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 165, "inputs_pretokenized": "使用____，目标程序可以不经过任何改动而装入主存直接执行。\nA. 静态重定位\nB. 动态重定位\nC. 编译或汇编\nD. 连接程序", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 166, "inputs_pretokenized": "Unix的在标准输入中查找包含指定模式的所有行，并将这些行写至标准输出的Unix命令是____。\nA. grep\nB. find\nC. file\nD. sed", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 167, "inputs_pretokenized": "在下列的存储管理算法中，内存的分配和释放平均时间之和为最大的是____。\nA. 首次适应法\nB. 循环首次适应法\nC. 最佳适应算法\nD. 最差适应法", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 168, "inputs_pretokenized": "如要能快速随机存取、插入和删除文件中的记录，下列的文件组织方法中，最合适的是____。\nA. 堆\nB. 索引顺序文件\nC. 索引文件\nD. 散列文件", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 169, "inputs_pretokenized": "在下面____的情况时，Unix系统不会进行进程切换调度。\nA. runrun标志还没有设置\nB. 进程正在执行系统调用signal\nC. 现运行进程的优先级没有降低\nD. 0#进程进入了睡眠状态", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 170, "inputs_pretokenized": "Unix在块设备读写时设置延迟写的原因是____。\nA. buf含有B-BUSY标志，等该标志清除后再写\nB. 正在读写该缓存，缓存控制块含有“忙标志” 等该标志清除后再写\nC. 为了减少I/O次数\nD. I/O设备正忙，等设备处于空闲状态后再写", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 171, "inputs_pretokenized": "Unix系统的磁盘存储空间的空闲块成组链接管理方式可用于____的分配与回收。\nA. 外存inode\nB. 文件目录块\nC. 文件超级块\nD. 磁盘自举块", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 172, "inputs_pretokenized": "执行一个无限的Shell循环时采用____是错误的。\nA. while true\nB. while [ 1 ]\nC. while [ 0 ]\nD. while (1)", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 173, "inputs_pretokenized": "两个并发的父子进程之间可通过它们的____传递信息。\nA. 全局变量\nB. 动态变量\nC. 共享存储区\nD. 工作区", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 174, "inputs_pretokenized": "下列文件中属于逻辑结构概念的文件是____。\nA. 连续文件\nB. 系统文件\nC. 目录文件\nD. 流式文件", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 175, "inputs_pretokenized": "根据参数pathname给出的文件路径名来获取文件的外存I节点中的类型、大小、文件主等信息的系统调用是____。\nA. stat\nB. fstat\nC. fopen\nD. file", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 176, "inputs_pretokenized": "Unix系统中对换程序的主要功能是____。\nA. 进程映像在盘交换区与内存之间的传送\nB. 选择一个进程占有处理机\nC. 设置runin和runout标志\nD. 选择一个作业调出系统", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 177, "inputs_pretokenized": "Unix文件的物理结构为____结构。\nA. 顺序\nB. 链式\nC. 索引\nD. 散列", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
{"id": 178, "inputs_pretokenized": "下面分配方法中哪些是必须采用连续的内存分配方法是____。\nA. 页式\nB. 段式\nC. 可变分区\nD. 虚存", "choices_pretokenized": [" A", " B", " C", " D"], "label": 0, "targets_pretokenized": [""]}
